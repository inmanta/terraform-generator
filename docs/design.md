# Design of the terraform module generator

The generator runs in two stages:
1. Schema parsing, we take as input the resource and provider schema from the terraform providers and build a python object tree out of it.
2. Schema conversion, we convert our python object tree to inmanta entities using `inmanta-module-factory`.

## First stage: Schema parsing

The schema we receive from the provider is defined here: https://github.com/inmanta/inmanta-tfplugin/blob/7269bc7d28d751b5dc110161dae29a6209c3fb63/docs/tf_grpc_plugin/proto/inmanta_tfplugin/tfplugin5.proto

All the providers we interact with will return us when calling the `GetProviderSchema` method, an object containing the schema of the provider config, and all the schemas for the resources and data sources this provider can handle.  We convert this schema to our own object tree to build a representation of the schema that would be closer to how the schema is going to be translated in the inmanta DSL.  That way, in the next stage, for each object in the tree, we can simply say "emit the inmanta DSL objects corresponding to you", gather everything and put it in a module.  This also allows us to modify the schema a simplify it a little bit.  For example, different types will result in the same serialization, we will then all aggregate them as one type, simplifying the model generation later on.

Here is an overview of the different object types we can have in our tree:
 1. [`blocks`](https://github.com/inmanta/inmanta-tfplugin/blob/7269bc7d28d751b5dc110161dae29a6209c3fb63/docs/tf_grpc_plugin/proto/inmanta_tfplugin/tfplugin5.proto#L81)=[`schema.blocks.Block`](../src/terraform_module_generator/schema/blocks/block.py):  This corresponds to an entity in inmanta DSL, with attributes and potentially some nested entities.
 2. [`nested_block`](https://github.com/inmanta/inmanta-tfplugin/blob/7269bc7d28d751b5dc110161dae29a6209c3fb63/docs/tf_grpc_plugin/proto/inmanta_tfplugin/tfplugin5.proto#L102)=[`schema.blocks.NestedBlock`](../src/terraform_module_generator/schema/blocks/nested_block.py): This is a block with another parent block, in inmanta language, an entity with a parent entity.  There are different nesting types, which will impact how we can identify the nested block and how it should be serialized.  All those different types are represented by a different subclass:
    1. [`schema.blocks.GroupNestedBlock`](../src/terraform_module_generator/schema/blocks/group.py)
    1. [`schema.blocks.ListNestedBlock`](../src/terraform_module_generator/schema/blocks/list.py)
    1. [`schema.blocks.MapNestedBlock`](../src/terraform_module_generator/schema/blocks/map.py)
    1. [`schema.blocks.SetNestedBlock`](../src/terraform_module_generator/schema/blocks/set.py)
    1. [`schema.blocks.SingleNestedBlock`](../src/terraform_module_generator/schema/blocks/single.py)
 3. [`attributes`](https://github.com/inmanta/inmanta-tfplugin/blob/7269bc7d28d751b5dc110161dae29a6209c3fb63/docs/tf_grpc_plugin/proto/inmanta_tfplugin/tfplugin5.proto#L90)=[`schema.attributes.Attribute`](../src/terraform_module_generator/schema/attributes/base.py): This can either correspond to an attribute in inmanta DSL, or to a relation, depending on the type.  There are three categories of attributes types:
    1. [`schema.attributes.CollectionAttribute`](../src/terraform_module_generator/schema/attributes/collection.py): This can be either a [`schema.attributes.ListAttribute`](../src/terraform_module_generator/schema/attributes/list.py) or a [`schema.attributes.SetAttribute`](../src/terraform_module_generator/schema/attributes/set.py) or attributes, it will be translated to a list in inmanta DSL if the inner type is a primitive one, and to a relation if the inner type is converted to an entity (e.a. `schema.attributes.StructureAttribute`).
    2. [`schema.attributes.StructureAttribute`](../src/terraform_module_generator/schema/attributes/structure.py): This can either be a [`schema.attributes.TupleAttribute`](../src/terraform_module_generator/schema/attributes/tuple.py) or an [`schema.attributes.ObjectAttribute`](../src/terraform_module_generator/schema/attributes/object.py), and will be converted to an entity in inmanta DSL.  For the tuple, the attributes of the entity will be named `attrX`, where `X` is the position of the attribute in the tuple.  For the object, the name of the attributes are defined in the object definition (it is basically a json object).
    3. Other primitive types: This can be either of [`schema.attributes.BooleanAttribute`](../src/terraform_module_generator/schema/attributes/bool.py), [`schema.attributes.NumberAttribute`](../src/terraform_module_generator/schema/attributes/number.py) or [`schema.attributes.StringAttribute`](../src/terraform_module_generator/schema/attributes/string.py).
 4. [`schema`](https://github.com/inmanta/inmanta-tfplugin/blob/7269bc7d28d751b5dc110161dae29a6209c3fb63/docs/tf_grpc_plugin/proto/inmanta_tfplugin/tfplugin5.proto#L80)=[`scmea.Schema`](../src/terraform_module_generator/schema/base.py): This is the base class for all the starting point of an object tree representing the config of... something.  That something being either the [`schema.Provider`](../src/terraform_module_generator/schema/provider.py), a [`schema.Resource`](../src/terraform_module_generator/schema/resource.py) or a [`schema.DataSource`](../src/terraform_module_generator/schema/data_source.py) of this provider.

To construct the tree of object, we simply provide the schema object received from the terraform provider to the top most objects in the tree (resources, data sources and providers, which are just root `blocks`) and then all the tree builds itself recursively.  
In some place during the parsing, we will use mock objects, defined in [`schema.mocks`](../src/terraform_module_generator/schema/mocks/), this is because we will abuse a little bit the terraform schema, and not always make a one-to-one schema-to-python object conversion.  With tuples for example, we will fake to receive inner attributes block from the schema, so that the existing attributes classes can be used to represent and generate our entity attributes.  Those objects are then mocks of the objects returned by the generated protobuf-based library.

## Second stage: Schema conversion (module generation)

Once the schema has been parsed into our own object tree, it is quite easy to generate it.  We do this in a very consistent way across the generator.  Each object in the three will have a bunch of methods, which, once called, emit some inmanta DSL objects and attach them to the module builder passed to the method.  All those methods cache their results (thanks to the [`cache_method_result`](../src/terraform_module_generator/schema/helpers/cache.py#L11) decorator) so that they can be called as many times as needed, by all the different parts of the object tree that might need to reference it.  For example, an attribute of an entity will be accessed once to be added to the entity, once to be added to an index, and once in the implementation to attach the value of the attribute to a dict.  Thanks to the decorator, we know the method will only be called once, and will always return the same object.  
At the root of each tree, in the provider, resource and data source objects, you will find an `add_to_module` method, this is the starting point of the conversion.  This will add the resource, provider, data source to the module, and bring with it all the parts it needs.  (Sub entities, attributes, indices, implementations, etc.).
